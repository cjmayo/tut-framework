<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>Documentation</title>
  <link rel="shortcut icon" href="../tut.ico" />
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="tabs.css" rel="stylesheet" type="text/css" />
</head>
<body alink="#ff0000" bgcolor="#ffffff" leftmargin="4" link="#0000ff" marginheight="4" marginwidth="4" text="#000000" topmargin="4" vlink="#0000aa">
  <table width="640" border="0" cellpadding="0" cellspacing="0" summary="Header">
    <tr>
      <td>
        <a href="http://tut-framework.sourceforge.net/"><img src="../tut.png" border="0" align="left" alt="tut logo"/></a> 
      </td>
      <td>
        <h1>Documentation</h1>
      </td>
    </tr>
  </table>
  <hr />
  <table border="0" cellpadding="0" cellspacing="0" summary="Contend">
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Documentation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="el" href="index.html#intro">Introduction</a></p>
<ul>
<li><a class="el" href="index.html#intro_1">Features</a></li>
</ul>
<p><a class="el" href="index.html#organization">TUT tests organization</a></p>
<ul>
<li><a class="el" href="index.html#organization_1">Test application</a></li>
<li><a class="el" href="index.html#organization_2">Test groups</a></li>
<li><a class="el" href="index.html#organization_3">Tests</a></li>
</ul>
<p><a class="el" href="index.html#test">Writing simple test</a></p>
<ul>
<li><a class="el" href="index.html#test_1">Preamble</a></li>
<li><a class="el" href="index.html#test_2">Skeleton</a></li>
<li><a class="el" href="index.html#test_3">Creating Test Group</a></li>
</ul>
<p><a class="el" href="index.html#creating">Creating Tests</a></p>
<ul>
<li><a class="el" href="index.html#creating_1">First real test</a> <a class="el" href="index.html#running">Running tests</a></li>
</ul>
<p><a class="el" href="index.html#developing">Develop TUT</a></p>
<ul>
<li><a class="el" href="index.html#developing_1">Prerequesits</a></li>
<li><a class="el" href="index.html#developing_2">Compiling the selftest and samples</a></li>
</ul>
<h1><a class="anchor" id="intro"></a>
Introduction</h1>
<p>TUT is a pure C++ unit test framework. Its name - TUT - stands for Template Unit Tests.</p>
<ul>
<li>TUT is very portable, no matter what compiler or OS you use.</li>
<li>TUT consists of header files only. No libraries required, deployment has never been easier.</li>
<li>Custom reporter interface allows to integrate TUT with virtually any IDE or tool in the world.</li>
<li>Support for multi-process testing (testing deadlocks and timeouts is under way).</li>
<li>TUT is free and distributed under a BSD-like license.</li>
<li>Tests are organised into named test groups.</li>
<li>Regression (all tests in the application), one-group or one-test execution.</li>
<li>Pure C++, no macros!</li>
<li>TUT tests are easy to read and maintain. see the examples <a href="examples.html">examples</a></li>
</ul>
<h2><a class="anchor" id="intro_1"></a>
Features</h2>
<p>TUT provides all features required for unit testing:</p>
<ul>
<li>Similar tests can be grouped together into test groups. Each test group has its unique name and is located in a separate compilation unit. One group can contain almost unlimited number of tests (actually, the limit is the compiler template recursion depth).</li>
<li>User can run all the tests (regression), or just some selected groups or even some tests in these groups.</li>
<li>TUT provides special template functions to check the condition validity at run-time and to force test failure if required. Since C++ doesn't provide a facility for obtaining stack trace of the throwed exception and TUT avoids macros, those functions accept string marker to allow users easely determine the source of exception.</li>
<li>TUT contains callback that can be implemented by the calling code to integrate with an IDE, for example. Callbacks tell listener when a new test run started, when test runner switches to the next tests group, when a test was completed (and what result it has), and when test run was finished. The callbacks allow users to produce their own visualization format for test process and results.</li>
<li>Being a template library, it doesn't need compilation; just include the &lt;<a class="el" href="tut_8hpp_source.html">tut/tut.hpp</a>&gt; header into the test modules.</li>
</ul>
<h1><a class="anchor" id="organization"></a>
TUT tests organization</h1>
<h2><a class="anchor" id="organization_1"></a>
Test application</h2>
<p>C++ produces executable code, so tests have to be compiled into a single binary called test application. The application can be built in automated mode to perform nightly tests. They also can be built manually when a developer hunts for bugs.</p>
<p>The test application contains tests, organized into test groups.</p>
<h2><a class="anchor" id="organization_2"></a>
Test groups</h2>
<p>The functionality of a tested application can be divided into a few separate function blocks (e.g. User Rights, Export, Processing, ...). It is natural to group together tests for each block. TUT invokes this test group. Each test group has a unique human-readable name and normally is located in a separate file.</p>
<h2><a class="anchor" id="organization_3"></a>
Tests</h2>
<p>Each single test usually checks only one specific element of functionality. For example, for a container a test could check whether size() call returns zero after the successful call to the clear() method.</p>
<h1><a class="anchor" id="test"></a>
Writing simple test</h1>
<h2><a class="anchor" id="test_1"></a>
Preamble</h2>
<p>You are going to create a new class for your application. You decided to write tests for the class to be sure it works while you are developing or, possibly, enhancing it. Let's consider your class is shared pointer: std::auto_ptr-alike type that shares the same object among instances.</p>
<p>Prior to test writing, you should decide what to test. Maximalist's approach requires to write so many tests that altering any single line of your production code will break at least one of them. Minimalist's approach allows one to write tests only for the most general or the most complex use cases. The truth lies somewhere in between, but only you, developer, know where. You should prepare common successful and unsuccessful scenarios, and the scenarios for testing any other functionality you believe might be broken in some way.</p>
<p>For our shared_ptr we obviosly should test constructors, assignment operators, referencing and passing ownership.</p>
<h2><a class="anchor" id="test_2"></a>
Skeleton</h2>
<p>If you don't have any implemented class to test yet, it would be good to implement it as a set of stubs for a first time. Thus you'll get an interface, and be able to write your tests. Yes, that's correct: you should write your tests before writing code! First of all, writing tests often helps to understand oddities in the current interface, and fix it. Secondly, with the stubs all your tests will fail, so you'll be sure they do their job.</p>
<h2><a class="anchor" id="test_3"></a>
Creating Test Group</h2>
<p>Since we're writing unit tests, it would be a good idea to group the tests for our class in one place to be able to run them separately. It's also natural in C++ to place all the grouped tests into one compilation unit (i.e. source file). So, to begin, we should create a new file. Let's call it test_shared_ptr.cpp. (Final variant of the test group can be found in examples/shared_ptr subdirectory of the distribution package)</p>
<div class="fragment"><div class="line"><span class="comment">// test_shared_ptr.cpp</span></div>
<div class="line"><span class="preprocessor">#include &lt;tut/tut.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>tut</div>
<div class="line">{</div>
<div class="line">}</div>
</div><!-- fragment --><p>As you see, you need to include TUT header file (as expected) and use namespace tut for tests. You may also use anonymous namespace if your compiler allows it (you will need to instantiate methods from tut namespace and some compilers refuse to place such instantiations into the anonymous namespace).</p>
<p>A test group in TUT framework is described by the special template test_group&lt;T&gt;. The template parameter T is a type that will hold all test-specific data during the test execution. Actually, the data stored in T are member data of the test. Test object is inherited from T, so any test can refer to the data in T as its member data.</p>
<p>For simple test groups (where all data are stored in test local variables) type T is an empty struct.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;tut/tut.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>tut</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">struct </span>shared_ptr_data</div>
<div class="line">  { </div>
<div class="line">  };</div>
<div class="line">}</div>
</div><!-- fragment --><p>But when tests have complex or repeating creation phase, you may put data members into the T and provide constructor (and, if required, destructor) for it. For each test, a new instance of T will be created. To prepare your test for execution TUT will use default constructor. Similarly, after the test has been finished, TUT calls the destructor to clean up T. I.e.:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;tut/tut.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>tut</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">struct </span>complex_data</div>
<div class="line">  {</div>
<div class="line">    connection* con;</div>
<div class="line">    complex_data(){ con = db_pool.get_connection(); }</div>
<div class="line">    ~complex_data(){ db_pool.release_connection(con); }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="comment">// each test from now will have con data member initialized</span></div>
<div class="line">  <span class="comment">// by constructor:</span></div>
<div class="line">  ...</div>
<div class="line">  con-&gt;commit();</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>What will happen if the constructor throws an exception? TUT will treat it as if test itself failed with exception, so this test will not be executed. You'll see an exception mark near the test, and if the constructor throwed something printable, a certain message will appear.</p>
<p>Exception in destructor is threated a bit different. Reaching destruction phase means that the test is passed, so TUT marks test with warning status meaning that test itself was OK, but something bad has happend after the test.</p>
<p>Well, all we have written so far is just a type declaration. To work with a group we have to have an object, so we must create the test group object. Since we need only one test group object for each unit, we can (and should, actually) make this object static. To prevent name clash with other test group objects in the namespace tut, we should provide a descriptive name, or, alternatively, we may put it into the anonymous namespace. The former is more correct, but a descriptive name usually works well too, unless you're too terse in giving names to objects.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;tut/tut.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>tut</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>shared_ptr_data</div>
<div class="line">    {</div>
<div class="line"></div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> test_group&lt;shared_ptr_data&gt; tg;</div>
<div class="line">    tg shared_ptr_group(<span class="stringliteral">&quot;shared_ptr&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>As you see, any test group accepts a single parameter - its human-readable name. This name is used to identify the group when a programmer wants to execute all tests or a single test within the group. So this name shall also be descriptive enough to avoid clashes. Since we're writing tests for a specific unit, it's enough to name it after the unit name.</p>
<p>Test group constructor will be called at unspecified moment at the test application startup. The constructor performs self-registration; it calls tut::runner and asks it to store the test group object name and location. Any other test group in the system undergoes the same processing, i.e. each test group object registers itself. Thus, test runner can iterate all test groups or execute any test group by its name.</p>
<p>Newly created group has no tests associated with it. To be more precise, it has predefined set of dummy tests. By default, there are 50 tests in a group, including dummy ones. To create a test group with higher volume (e.g. when tests are generated by a script and their number is higher) we must provide a higher border of test group size when it is instantiated:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;tut/tut.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>tut</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>huge_test_data</div>
<div class="line">    {</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="comment">// test group with maximum 500 tests</span></div>
<div class="line">    <span class="keyword">typedef</span> test_group&lt;huge_test_data,500&gt; testgroup;</div>
<div class="line">    testgroup huge_test_testgroup(<span class="stringliteral">&quot;huge group&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note also, that your compiler will possibly need a command-line switch or pragma to enlarge recursive instantiation depth. For g++, for example, you should specify at least &ndash;ftemplate-depth-501 to increase the depth. For more information see your compiler documentation.</p>
<h1><a class="anchor" id="creating"></a>
Creating Tests</h1>
<p>Now it's time to fill our test group with content.</p>
<p>In TUT, all tests have unique numbers inside the test group. Some people believe that textual names better describe failed tests in reports. I agree; but in reality C++ templates work good with numbers because they are compile-time constants and refuse to do the same with strings, since strings are in fact addresses of character buffers, i.e. run-time data.</p>
<p>As I mentioned above, our test group already has a few dummy tests; and we can replace any of them with something real just by writing our own version:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;tut/tut.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>tut</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>shared_ptr_data{};</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> test_group&lt;shared_ptr_data&gt; testgroup;</div>
<div class="line">    <span class="keyword">typedef</span> testgroup::object testobject;</div>
<div class="line">    testgroup shared_ptr_testgroup(<span class="stringliteral">&quot;shared_ptr&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span>&lt;&gt;</div>
<div class="line">    <span class="keyword">template</span>&lt;&gt;</div>
<div class="line">    <span class="keywordtype">void</span> testobject::test&lt;1&gt;()</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// do nothing test</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>So far this test does nothing, but it's enough to illustrate the concept.</p>
<p>All tests in the group belong to the type test_group&lt;T&gt;::object. This class is directly inherited from our test data structure. In our case, it is</p>
<p>class object : public shared_ptr_data { ... }</p>
<p>This allows to access members of the data structure directly, since at the same time they are members of the object type. We also typedef the type with testobject for brevity.</p>
<p>We mark our test with number 1. Previously, test group had a dummy test with the same number, but now, since we've defined our own version, it replaces the dummy test as more specialized one. It's how C++ template ordering works.</p>
<p>The test we've written always succeeds. Successful test returns with no exceptions. Unsuccessful one either throws an exception, or fails at fail() or ensure() methods (which anyway just throw the exception when failed).</p>
<h2><a class="anchor" id="creating_1"></a>
First real test</h2>
<p>Well, now we know enough to write the first real working test. This test will create shared_ptr instances and check their state. We will define a small structure (keepee) to use it as shared_ptr stored object type.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;tut/tut.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;shared_ptr.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>tut</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>shared_ptr_data</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">struct </span>keepee{ <span class="keywordtype">int</span> data; };</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> test_group&lt;shared_ptr_data&gt; testgroup;</div>
<div class="line">    <span class="keyword">typedef</span> testgroup::object testobject;</div>
<div class="line">    testgroup shared_ptr_testgroup(<span class="stringliteral">&quot;shared_ptr&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span>&lt;&gt;</div>
<div class="line">    <span class="keyword">template</span>&lt;&gt;</div>
<div class="line">    <span class="keywordtype">void</span> testobject::test&lt;1&gt;()</div>
<div class="line">    {</div>
<div class="line">        set_test_name(<span class="stringliteral">&quot;Checks default constructor&quot;</span>);</div>
<div class="line">        shared_ptr&lt;keepee&gt; def;</div>
<div class="line">        ensure(<span class="stringliteral">&quot;null&quot;</span>, def.get() == 0);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>That's all! The first line creates shared_ptr. If constructor throws an exception, test will fail (exceptions, including '...', are catched by the TUT framework). If the first line succeeds, we must check whether the kept object is null one. To do this, we use test object member function ensure(), which throws std::logic_error with a given message if its second argument is not true. Finally, if destructor of shared_ptr fails with exception, TUT also will report this test as failed.</p>
<p>It's equally easy to write a test for the scenario where we expect to get an exception: let's consider our class should throw an exception if it has no stored object, and the operator -&gt; is called.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line"><span class="keywordtype">void</span> testobject::test&lt;2&gt;()</div>
<div class="line">{</div>
<div class="line">    set_test_name(<span class="stringliteral">&quot;Checks operator -&gt; throws instead of returning null&quot;</span>);</div>
<div class="line">    <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">        shared_ptr&lt;keepee&gt; sp;</div>
<div class="line">        sp-&gt;data = 0;</div>
<div class="line">        fail(<span class="stringliteral">&quot;exception expected&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span>( <span class="keyword">const</span> std::runtime_error&amp; ex )</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// ok</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here we expect the std::runtime_error. If operator doesn't throw it, we'll force the test to fail using another member function: fail(). It just throws std::logic_error with a given message. If operator throws anything else, our test will fail too, since we intercept only std::runtime_error, and any other exception means the test has failed.</p>
<p>NB: our second test has number 2 in its name; it can, actually, be any in range 1..Max; the only requirement is not to write tests with the same numbers. If you did, compiler will force you to fix them anyway.</p>
<p>And finally, one more test to demonstrate how to use the ensure_equals template member function:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line"><span class="keywordtype">void</span> testobject::test&lt;3&gt;()</div>
<div class="line">{</div>
<div class="line">    set_test_name(<span class="stringliteral">&quot;Checks keepee counting&quot;</span>);</div>
<div class="line">    shared_ptr&lt;keepee&gt; sp1(<span class="keyword">new</span> keepee());</div>
<div class="line">    shared_ptr&lt;keepee&gt; sp2(sp1);</div>
<div class="line">    ensure_equals(<span class="stringliteral">&quot;second copy at sp1&quot;</span>,sp1.count(),2);</div>
<div class="line">    ensure_equals(<span class="stringliteral">&quot;second copy at sp2&quot;</span>,sp2.count(),2);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The test checks if the shared_ptr correctly counts references during copy construction. What's interesting here is the template member ensure_equals. It has an additional functionality comparing with similar call ensure("second_copy",sp1.count()==2); it uses operator == to check the equality of the two passed parameters and, what's more important, it uses std::stream to format the passed parameters into a human-readable message (smth like: "second copy: expected 2, got 1"). It means that ensure_equals cannot be used with the types that don't have operator &lt;&lt;; but for those having the operator it provides much more informational message.</p>
<p>In contrast to JUnit assertEquals, where the expected value goes before the actual one, ensure_equals() accepts the expected after the actual value. I believe it's more natural to read ensure_equals("msg", count, 5) as "ensure that count equals to 5" rather than JUnit's "assert that 5 is the value of the count".</p>
<h1><a class="anchor" id="running"></a>
Running tests</h1>
<p>Tests are already written, but an attempt to run them will be unsuccessful. We need a few other bits to complete the test application.</p>
<p>First of all, we need a main() method, simply because it must be in all applications. Secondly, we need a test runner singleton. Remember I said each test group should register itself in singleton? So, we need that singleton. And, finally, we need a kind of a callback handler to visualize our test results.</p>
<p>The design of TUT doesn't strictly set a way the tests are visualized; instead, it provides an opportunity to get the test results by means of callbacks. Moreover it allows user to output the results in any format he prefers. Of course, there is a "reference implementation" in the example/subdirectory of the project.</p>
<p>Test runner singleton is defined in <a class="el" href="tut_8hpp_source.html">tut/tut.hpp</a>, so all we need to activate it is to declare an object of the type <a class="el" href="classtut_1_1test__runner__singleton.html">tut::test_runner_singleton</a> in the main module with a special name tut::runner.</p>
<p>Now, with the test_runner we can run tests. Singleton has method get() returning a reference to an instance of the test_runner class, which in turn has methods run_tests() to run all tests in all groups, run_tests(const std::string&amp; groupname) to run all tests in a given group and run_test(const std::string&amp; grp,int n) to run one test in the specified group.</p>
<div class="fragment"><div class="line"><span class="comment">// main.cpp</span></div>
<div class="line"><span class="preprocessor">#include &lt;tut/tut.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>tut</div>
<div class="line">{</div>
<div class="line">    test_runner_singleton runner;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// run all tests in all groups</span></div>
<div class="line">    runner.get().<a class="code" href="classtut_1_1test__runner.html#a90809d5b9d672ed20f9f1c0d964ae288">run_tests</a>();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// run all tests in group &quot;shared_ptr&quot;</span></div>
<div class="line">    runner.get().<a class="code" href="classtut_1_1test__runner.html#a90809d5b9d672ed20f9f1c0d964ae288">run_tests</a>(<span class="stringliteral">&quot;shared_ptr&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// run test number 5 in group &quot;shared_ptr&quot;</span></div>
<div class="line">    runner.get().<a class="code" href="classtut_1_1test__runner.html#adcac0e972861722301cecefa34570d2f">run_test</a>(<span class="stringliteral">&quot;shared_ptr&quot;</span>,5);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>It's up to user to handle command-line arguments or GUI messages and map those arguments/messages to actual calls to test runner. Again, as you see, TUT doesn't restrict user here.</p>
<p>But, the last question is still unanswered: how do we get our test results? The answer lies inside <a class="el" href="structtut_1_1callback.html">tut::callback</a> interface. User shall create its subclass, and write up to three simple methods. He also can omit any method since they have default no-op implementation. Each corresponding method is called in the following cases:</p>
<ul>
<li>a new test run started;</li>
<li>test finished;</li>
<li>test run finished.</li>
</ul>
<p>Here is a minimal implementation:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>visualizator : <span class="keyword">public</span> <a class="code" href="structtut_1_1callback.html">tut::callback</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="structtut_1_1callback.html#a08f75d60e605a385f421ff721828bcce">run_started</a>(){ }</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="structtut_1_1callback.html#ac33d5b55077ef53033aa9970af815421">test_completed</a>(<span class="keyword">const</span> <a class="code" href="structtut_1_1test__result.html">tut::test_result</a>&amp; tr)</div>
<div class="line">  {</div>
<div class="line">      <span class="comment">// ... show test result here ...</span></div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="structtut_1_1callback.html#abfc3b8df9de6545fd8b823f7e552ee88">run_completed</a>(){ }</div>
<div class="line">};        </div>
</div><!-- fragment --><p>The most important is the test_completed() method; its parameter has type test_result, and contains everything about the finished test, from its group name and number to the exception message, if any. Member result is an enum that contains status of the test: ok, fail or ex. Take a look at the examples/basic/main.cpp for more complete visualizator.</p>
<p>Visualizator should be passed to the test_runner before run. Knowing that, we are ready to write the final version of our main module:</p>
<div class="fragment"><div class="line"><span class="comment">// main.cpp</span></div>
<div class="line"><span class="preprocessor">#include &lt;tut/tut.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>tut</div>
<div class="line">{</div>
<div class="line">  test_runner_singleton runner;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>callback : <span class="keyword">public</span> <a class="code" href="structtut_1_1callback.html">tut::callback</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="structtut_1_1callback.html#a08f75d60e605a385f421ff721828bcce">run_started</a>(){ std::cout &lt;&lt; <span class="stringliteral">&quot;\nbegin&quot;</span>; }</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="structtut_1_1callback.html#ac33d5b55077ef53033aa9970af815421">test_completed</a>(<span class="keyword">const</span> <a class="code" href="structtut_1_1test__result.html">tut::test_result</a>&amp; tr)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; tr.test_pos &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; tr.result &lt;&lt; std::flush;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="structtut_1_1callback.html#abfc3b8df9de6545fd8b823f7e552ee88">run_completed</a>(){ std::cout &lt;&lt; <span class="stringliteral">&quot;\nend&quot;</span>; }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  callback clbk;</div>
<div class="line">  runner.get().<a class="code" href="classtut_1_1test__runner.html#a1b74126e820d26de2192861f02a547c9">set_callback</a>(&amp;clbk);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// run all tests in all groups</span></div>
<div class="line">  runner.get().<a class="code" href="classtut_1_1test__runner.html#a90809d5b9d672ed20f9f1c0d964ae288">run_tests</a>();</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>That's it. You are now ready to link and run our test application. Do it as often as possible; once a day is a definite must. I hope, TUT will help you to make your application more robust and relieve your testing pain.</p>
<p>Feel free to send your questions, suggestions and critical opinions to me; I'll do my best to address them asap.</p>
<h1><a class="anchor" id="developing"></a>
Develop TUT</h1>
<h2><a class="anchor" id="developing_1"></a>
Prerequesits</h2>
<p>TUT is a template library, for testing this files you need:</p>
<ul>
<li>C++ compiler</li>
<li>python 2.6</li>
</ul>
<p>If you build the Documentation you need also:</p>
<ul>
<li>ruby</li>
<li>webgen (gem install webgen)</li>
<li>make (for Windows you can install GnuWin32 or WinAVR)</li>
<li>doxygen</li>
<li>graphviz</li>
</ul>
<p>After installing all these programs, you need some changes at your environment. (depend on the system witch you use) For example Win: needs python and ruby in the %PATH% variable.</p>
<h2><a class="anchor" id="developing_2"></a>
Compiling the selftest and samples</h2>
<p>Go into the directory where the tut is. Call:</p>
<ul>
<li>UNIX: ./waf configure</li>
<li>Win: python.exe waf configure</li>
</ul>
<p>Build the sources:</p>
<ul>
<li>UNIX: ./waf</li>
<li>Win: python.exe waf</li>
</ul>
<p>Run the selftest:</p>
<ul>
<li>UNIX: build/default/self_test</li>
<li>Win: build/default/self_test.exe</li>
</ul>
<p>if there is no error you can install tut</p>
<ul>
<li>UNIX: ./waf install</li>
<li>Win: python.exe waf install</li>
</ul>
<p>or copy the contend of the include directory to your include directory. Additional copy 'build/default/include/tut/tut_config.hpp'</p>
<p>Build the Documentation:</p>
<p>Goto the directory doc/webgen and call make</p>
<p>the documentation will be build in the out directory. Install this directory on the Webserver. Or call make deploy if you are maintainer.</p>
<p>Thats all, Have Fun! </p>
</div></div><!-- contents -->
   
</table><br>
<table border="0" cellpadding="0" cellspacing="0" summary="Footer">
  <tr>
    <td align="center">
      <font color="#0086b2" size="-1">
        <i>
           <small>All Rights Reserved. Generated on Tue Dec 17 2013 23:08:48 for TUT by doxygen 1.8.5</small>
        </i>
      </font>
    </td>
  </tr>
</table>
</body></html>
